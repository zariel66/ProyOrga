.data
	titulo: .asciiz "Proyecto Organización\nPrimer Parcial\n"
	menuString: .asciiz "\nIngrese una opción del menú\n1.-Suma en Decimal\n2.-Suma en hexadecimal\n3.-Suma Mixta\nIngrese una opción\n"
	numeroActual: .word #Utilizar s1, contiene el número actual en base a los digitos capturados
	errorOpcion: .asciiz "\nEL VALOR INGRESADO NO ES UNA OPCIÓN VÁLIDA\n"
	stringOpcion1: .asciiz "\nIngrese número enteros separados por enter\n"
	opcionError1: .asciiz "\nEl número ingresado no es entero. Ingrese otro valor:\n"
	resultadoSuma: .asciiz "\nEl resultado de la suma es:\n"
	cadena: .space 64
	msg_1:	.asciiz "\nIngrese un número hexadecimal, o presione enter para obtener el resultado \n"
	msg_2:  .asciiz "\La suma total de los números ingresados es: "
	msg_3:  .asciiz "\n La suma no se puede representar en 32 bits. El resultado es incorrecto. \n"
	newLine: .asciiz "\n"
	msg_Error_1: .asciiz "El número ingresado no es hexadecimal.\n"
	msg_Error_2: .asciiz " \nPor favor, ingrese el prefijo 0x antes del número hexadecimal!\n"
	overflowmsg: .asciiz "\nLA SUMA EXCEDIÓ LOS LÍMITES. EL MÁXIMO VALOR POSIBLE ES 7fffffff O 2147483647\n"
	
.text
	#MUESTRA EL SALUDO	
	main: #etiquitea donde inicia la ejecución del programa
		la $a0,titulo #argumento de syscall para impresion de cadena por pantalla
		jal imprimir		
		j menu #salto a la etiquita Menu
	#MUESTRA EL MENÚ
	menu:
		la $a0,menuString #impresión del menú
		jal imprimir
		j opciones
	#CAPTURA LA OPCIÓN Y VALIDA
	opciones:
		li $v0,12 #codigo de input del sistema para leer caracter
		syscall
		add $a3,$v0,$zero #cargo el caracter en el registro $a3
		li $a0,'1'
		li $a1,'3'
		jal caracterEnRango
		add $t0,$v0,$zero #copio el resultado
		beq $zero,$t0,opcionIncorrecta	#si la opción es incorrecta muestra error
		andi $s0,$a3, 0x0F #convierto el valor numérico del caracter a su correspondiente número
		addi $t0,$zero,1
		addi $t1,$zero,2
		addi $t2,$zero,3
		#switch de las opciones
		beq $s0,$t0,opcion1
		beq $s0,$t1,opcion2
		beq $s0,$t2,opcion3
		j terminarPrograma
		opcionIncorrecta:
			la $a0,errorOpcion #imprime el mensaje de error de opción
			li $v0,4
			syscall
			j menu
	#VERIFICA SI $a3(CARACTER ACTUAL) CONTIENE UN DÍGITO DENTRO DEL RANGO DE $a0 Y $a1
	#RETORNA 1(uno) si es correcto y 0(cero) si es incorrecto
	caracterEnRango:
		slt $t0,$a3,$a0  #Comparo si el caracter enviado es menor al valor del caracter '0'
		li $t1,1
		beq  $t0,$t1,caracterInvalido #si el resultado de la comparacion es menor(=1) entonces no es digito
		add $t1,$zero,$a1
		bgt $a3,$t1,caracterInvalido  #si el resultado de la comparacion es mayor entonces no es digito
		addi $v0,$zero,1 #retorna 1 si el digito es valido
		jr $ra
		caracterInvalido:
			addi $v0,$zero,0 # retorna 0 si no es un digito
			jr $ra
	imprimir:
		li $v0,4 #constante 4 que activa impresion de cadena por pantalla
		syscall
		jr $ra
	opcion1:
		addi $s0,$zero,0 #registro donde se almacena el resultado de la suma
		addi $v0,$zero,4
		la $a0,stringOpcion1 #imprimo el dialogo de la opción 1
		syscall
		loop1: #mientras hayan nuevas entradas sigo pidiendo números
			jal pedirInputEntero #pido el input
			beq $v0,$zero,MostrarResultadoEntero #si retorna 0 muestro el resultado
			li $t0,-1
			beq $v0,$t0,loop1
			addu $s0,$s0,$v0
			j loop1
	pedirInputEntero:
		addi $v0,$zero,8
		la $a0,cadena
		la $a1,cadena #input de la cadena
		syscall
		lb $t0,0($a0)
		li $t1,'\n'
		beq $t0,$t1,terminarInput #verifico si el usuario solo dio enter
		addi $sp,$sp,-4
		sw $ra,0($sp) #guardo la dirección de retorno en la pila
		jal obtenerEntero
		lw $ra,0($sp) #recupero la dirección de retorno
		addi $sp,$sp,4
		jr $ra
		terminarInput:
			li $v0,0
			jr $ra
	obtenerEntero:
		addi $t0,$a0,0 #cadena
		addi $t1,$zero,0 #iterador
		addi $t4,$zero,0 #número
		loop2:
			add $t1,$t1,$t0 #recupero la direccion actual en la posicion i
			lb $a3,0($t1) #recupero el caracter
			li $t2,'\0'
			li $t3,'\n'
			beq $t2,$a3,devolverEntero #SI ES FIN DE CADENA DEVUELVE EL NÚMERO
			beq $t3,$a3,devolverEntero #SI ES UN ENTER DE CADENA DEVUELVE EL NÚMERO
			addi $sp,$sp,-12 # genero espacio en la pila	
			sw $t1,8($sp)
			sw $t0,4($sp)
			sw $ra,0($sp)
			li $a0,'0'
			li $a1,'9'
			jal caracterEnRango
			lw $t1,8($sp)
			lw $t0,4($sp)
			lw $ra,0($sp)
			addi $sp,$sp,12 #recupero espacio en la pila
			beq $zero,$v0,errorEntero
			sub $t1,$t1,$t0
			andi $t2,$a3,0x0F
			addi $t3,$t4,0
			sll $t4,$t4,3 #multiplico por 8
			add $t3,$t3,$t3 #sumo dos veces más equivalente a multiplicar por 10
  			add $t4,$t4,$t3
  			add $t4,$t4,$t2	#sumo el caracter actual
			addi $t1,$t1,1 #incremento el iterador
			j loop2
		devolverEntero:
			addi $v0,$t4,0 #devuelve el numero en $t4
			jr $ra
		errorEntero:
			li $v0,4
			la $a0,opcionError1 #impresion de error de input
			syscall
			li $v0,-1
			jr $ra
		OVERFLOW:
			la $a0,overflowmsg
			li $v0,4 #constante 4 que activa impresion de cadena por pantalla
			syscall
			j menu
	MostrarResultadoEntero:
		la $a0,resultadoSuma
		li $v0,4 #constante 4 que activa impresion de cadena por pantalla
		syscall
		addi $a0,$s0,0
		li $v0,1 #constante 1 que activa impresion de entero por pantalla
		syscall
		j terminarPrograma
			
	
	opcion2:
	
		# Este bloque de código: 
		# Pide un string al usuario;.
		# Calcula el número de caracteres a convertir.
		# Convierte cada caracter a su equivalente decimal (i.e 'a'=10);
		# Convierte el número hexadecimal en decimal (i.e 0xabc = 2748)
		# Suma el resultado decimal a un acumulador  (i.e 2748 + (0x1+0x1) = 2750)
		# El acumulador tiene el resultado de la suma
		# Variables:
		# $s7 es el acumulador con la respuesta
		# $s6 = (número de caracteres a convertir) - 1 (i.e 0xabc => $s6 = 2)
		# $s5 contiene la dirección base del string
		
		
	
			li $s7, 0			# $s7 es el acumulador con la respuesta.	
		hex:	la $a0, msg_1		
			li $v0,4
			syscall

			li $v0,8			# Solicita el número al usuario.
			la $a0,cadena			# Guarda el string en memoria
			li $a1,64 			# Límite de caracteres permitidos
			syscall				
																					
			add $s5, $a0, $0		# Pasa la dirección efectiva del string de $a0 a $s5
			li $a1, 0
			lb $a0, 0($s5)	
			li $t0, 10
			beq $a0, $t0, Exit_hex		# Verifica si el usuario solo presiono "enter"
			lb $a0, 1($s5)			
			li $t1, 120			# Verifica si el segundo caracter del string es "x". (Para combrobar si es hexadecimal)
			bne $a0, $t1,Err_2
			
	    		li $s6, 0			# En $s6 se usará para convertir el número de hexadecimal a decimal.
	    	strlen:	add $t2, $s6, $s5		# Se itera a lo largo del string
	    		lb $t1,0($t2)
	    		addi $s6,$s6,1				
			bne $t1,$t0, strlen	
			addi $s6, $s6,-4		# Número caracteres a convertir = $s6 + 1
			
		hexSum:	add $t0, $s5, $a1		# Itero por cada caracter del string. $a1 es el iterador.
			lb $a0, 2($t0)			# Cargo el caracter del string a $a0
			li $t0, 10
			beq $a0, 10, hex		# Verifico si el caracter es un salto de linea
							
		hexVal:	li $t6,96			# Este bloque valida si los caracteres pertecen a la base hexadecimal.
			li $t7,64			# función lógica => ($a0 > 96 && $a0 <103)||($a0 > 64 && $a0 < 71)||($a0 > 47 && $a0 < 58)
			li $t8,47
			slt $t0,$t6,$a0				
			slti $t1,$a0,103	
			slt $t2,$t7,$a0
			slti $t3,$a0,71
			slt $t4,$t8,$a0
			slti $t5,$a0,58
			and  $t1,$t0,$t1 
			and  $t3,$t2,$t3 
			and  $t5,$t4,$t5 
			or $t0, $t1, $t3
			or $v0, $t0, $t5
			beq $v0,$zero,Err_1
			
		hexC_0:	li $t6,96			# Este bloque convierte $a0 a su equivalente decimal. i.e $a0='a'=97(ascii)=10(base10)
			li $t7,64
			li $t8,47
			slt $t0,$t6,$a0				
			slti $t1,$a0,103	
			and $t1,$t0,$t1 
			bne $t1, $zero, hexC_1
			slt $t2,$t7,$a0
			slti $t3,$a0,71
			and $t3,$t2,$t3 	
			bne $t3, $zero, hexC_2
			addi $a0, $a0, -48
			j Cont
		hexC_1:	addi $a0, $a0, -87
			j Cont
		hexC_2:	addi $a0, $a0, -55
			j Cont
			
		Cont: 	addi $sp, $sp, -12		# Cada valor decimal es multiplicado por 16^i. Donde i= $s6(# de caracteres)-$a1(iterador)
			sw $a1, 8($sp)	
			sw $ra, 4($sp)			
			sw $a0, 0($sp)
			sub $a1, $s6, $a1
			li $a0, 16
			jal pwr
			lw $a0, 0($sp)
			lw $ra, 4($sp)
			lw $a1, 8($sp)
			addi $sp, $sp, 8
			mult $v0,$a0			# $a0*(16^i)
			mflo $t0			
			add $s7, $s7, $t0		# Sumo el resultado de la multiplicación con el acumulador.
			addi $a1, $a1, 1		# Incremento el iterador
			j hexSum
		
		
							# Función potencia: $a0^$a1. Es recursiva. (16,$a1)*(16,$a1-1)*...*(16,0)
		pwr:	beq $a1,$zero,end_pwr		# Caso base ($a1=0)
			addi $sp, $sp, -4
			sw $ra, 0($sp)
			addi $a1, $a1, -1
			jal pwr
			mult $v0, $a0
			mflo $v0
			lw $ra, 0($sp)
			addi $sp, $sp, 4
			jr $ra
			
		end_pwr:li $v0, 1			# resultado del caso base (16^0)= 1	
			jr $ra
		
		Err_1:	li $v0, 4			# Mensajes de Error
			la $a0, msg_Error_1		# Número no hexadecimal
			syscall
			j hex			
		
		Err_2:	li $v0, 4
			la $a0, msg_Error_2		# Prefijo 0x no aparece el número hexadecimal	
			syscall
			j hex							
		
		Err_3:	li $v0, 4			# Mensajes
			la $a0, msg_3			# Suma fuera de rango
			syscall
			j hexEnd	
		
		
	    Exit_hex:	li $v0, 4
			la $a0, msg_2			# Suma total
			syscall
					
			li $v0, 1			# Impresión del resultado total
			add $a0, $s7, $zero
			syscall		
				
			slt $t0, $s7, $zero
			bne $t0, $zero, Err_3	 
			li $s7, 0			# Encero el acumulador con la respuesta
			
			li $v0, 4
			la $a0, newLine
			syscall			 				 	
				 			 	 			 	 			 	
	    hexEnd:	j menu
	    
	    
	    
	opcion3:
		j terminarPrograma
	terminarPrograma:
		li $v0,10 #termina el programa
		syscall
	

.ktext 0x80000180

	
	mfc0 $k0,$14   # Coprocessor 0 register $14 has address of trapping instruction
	la $k1,OVERFLOW
   	mtc0 $k1,$14   # Store new address back into $14        
        eret  # return from exception, PC <- EPC
		
	
	
